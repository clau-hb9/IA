// **RECUERDA** PRIORIDAD EN FUNCIÓN DEL ORDEN DE LAS REGLAS (LA SUPERIOR LA MÁS PRIORITARIA)

rule tareas_hechas{
declarations
    practica.objetos.Tarea t;
  preconditions
  	// Si la tarea ya esta hecha que la elimine de la BHH
    t.getUnidades() <= 0;
  actions
 	retract(t);
}

rule coger_primera_herramienta {
  declarations
    practica.objetos.Trabajador w;
    practica.objetos.Tarea t;
    practica.objetos.Herramienta nuevaH;
  preconditions
  	// Si un trabajador esta en el Almacen
  	w.getArea().equals("A");
  	// Si la nueva herramienta vale para hacer una tarea inacabada
  	nuevaH.getTrabajo().equals(t.getTipo());
  	// Si el trabajador no tiene herramienta
  	w.getHerramienta() == null;
  	
  actions
  	// Le damos la herramienta seleccionada al trabajador y se mantiene en el almacen
  	w.setHerramienta(nuevaH);
  	w.imprimeH();
  	modified(w);
}

rule hacer_tarea_limpieza {
  declarations
    practica.objetos.Tarea t;
    practica.objetos.Trabajador w;
  preconditions
  	// Si la herramienta del trabajador sirve para limpiar
    w.getHerramienta().getTrabajo().equals("limpiar");
    // Si la tarea a realizar es de limpiar
    t.getTipo().equals("limpiar");
    // Si el area de la tarea es la misma que el trabajador
    t.getArea().equals(w.getArea());
    // Si el trabajador tiene habilidad para hacer esa tarea
    w.getHabLimpiar() > 0;
    
  actions
  	// Determinamos las unidades finales de la tarea. Le restamos la habilidad del trabajador.
 	t.setUnidades(t.getUnidades() - w.getHabLimpiar());
 	t.imprime( w.getHerramienta(),w);
 	modified(t);
}

rule hacer_tarea_reparacion {
  declarations
    practica.objetos.Tarea t;
    practica.objetos.Trabajador w;
  preconditions
   	// Si la herramienta del trabajador sirve para reparar
    w.getHerramienta().getTrabajo().equals("reparar");
    // Si la tarea a realizar es de reparar
    t.getTipo().equals("reparar");
    // Si el area de la tarea es la misma que el trabajador
    t.getArea().equals(w.getArea());
    // Si el trabajador tiene habilidad para hacer esa tarea
    w.getHabReparar() > 0;
  actions
  	// Determinamos las unidades finales de la tarea. Le restamos la habilidad del trabajador.
 	t.setUnidades(t.getUnidades() - w.getHabReparar());
 	t.imprime( w.getHerramienta(),w);
 	modified(t);
}

rule hacer_tarea_poda {
  declarations
    practica.objetos.Tarea t;
    practica.objetos.Trabajador w;
  preconditions
   	// Si la herramienta del trabajador sirve para podar
    w.getHerramienta().getTrabajo().equals("podar");
    // Si la tarea a realizar es de podar
    t.getTipo().equals("podar");
    // Si el area de la tarea es la misma que el trabajador
    t.getArea().equals(w.getArea());
    // Si el trabajador tiene habilidad para hacer esa tarea
    w.getHabPodar() > 0;	
  actions
  	// Determinamos las unidades finales de la tarea. Le restamos la habilidad del trabajador.
 	t.setUnidades(t.getUnidades() - w.getHabPodar());
 	t.imprime(w.getHerramienta(),w);
 	modified(t);
}

rule moverse_hacer_tarea_adyacente {
  declarations
    practica.objetos.Area a;
    practica.objetos.Trabajador w;
    practica.objetos.Tarea t;
  preconditions
  	//  Si el area al que nos vamos a desplazar tiene una tarea por hacer
  	t.getArea().equals(a.getNombre()); 
  	// Si el trabajador tiene la herramienta necesaria para hacer la tarea
  	t.getTipo().equals(w.getHerramienta().getTrabajo()); 
  	// Si al area a donde queremos ir es adyacente al area en el que esta el trabajador
   	a.esAdyacente(w.getArea());
   	// Si ese area no es de donde viene el trabajador(evitar bucles)
   	!a.getNombre().equals(w.getAreaAnterior());
  actions
  	// Establecemos como area anterior del trabajador a la actual
  	w.setAreaAnterior(w.getArea());
  	// Desplazamos al trabajador a la nueva area 
  	w.setArea(a.getNombre());
  	w.imprime(t.getTipo());
  	modified(w);
}

rule moverse_hacer_tarea {
  declarations
    practica.objetos.Area a;
    practica.objetos.Trabajador w;
    practica.objetos.Tarea t;
  preconditions
  	// Seleccionamos areas adyacentes a la que está el trabajador
  	a.esAdyacente(w.getArea());
  	// Si ese trabajador no ha pasado ya por ese area con esa herramienta --> Evitamos hacer comprobaciones repetidas
   	!a.getVisitadaTarea(w.getHerramienta().getTrabajo());
   	// Si ese area no es de donde viene el trabajador(evitar bucles)
   	!a.getNombre().equals(w.getAreaAnterior());
   	// Si el trabajador tiene la herramienta necesaria para hacer alguna tarea restante del mapa
  	t.getTipo().equals(w.getHerramienta().getTrabajo()); 
   	
  actions
  	// Establecemos como area anterior del trabajador a la actual
  	w.setAreaAnterior(w.getArea());
  	// Desplazamos al trabajador a la nueva area 
  	w.setArea(a.getNombre());
  	// Ponemos esta area como visitada con esa herramienta --> Evitamos hacer comprobaciones repetidas
  	a.setVisitadaTarea(true,w.getHerramienta().getTrabajo());
  	w.imprime(t.getTipo());
  	modified(w);
  	modified(a);
}
rule coger_herramienta {
  declarations
    practica.objetos.Trabajador w;
    practica.objetos.Tarea t;
    practica.objetos.Herramienta nuevaH;
  preconditions
  	// Si el trabajador llega al almacen
  	w.getArea().equals("A");
  	// Si está la herramienta necesaria para resolver alguna tarea del mapa
  	nuevaH.getTrabajo().equals(t.getTipo());
  actions
  	// Le cambiamos la herramienta al trabajador
  	w.setHerramienta(nuevaH);
  	
  	w.imprimeH();
  	modified(w);
}

rule moverse_almacen_adyacente {
  declarations
    practica.objetos.Area a;
    practica.objetos.Trabajador w;
    practica.objetos.Tarea t;
  preconditions
  //ES IGUAL QUE moverse_hacer_tarea_adyacente SIN LA CONDICION DE QUE EL TRABAJADOR TIENE LA HERRAMIENTA NECESARIA PARA HACER UNA TAREA
  	// Obligamos a que el area al que nos queremos desplazar sea el almacen
  	a.getNombre().equals("A");
  	// Si todavía hay tareas inacabadas
  	t.getUnidades() > 0;
  	// Si el almacen es adyacente al area donde está el trabajador 
   	a.esAdyacente(w.getArea());
  actions
   	// Establecemos como area anterior del trabajador a la actual
  	w.setAreaAnterior(w.getArea());
  	// Desplazamos al trabajador al almacen
  	w.setArea(a.getNombre());
  	w.imprime(t.getTipo());
  	modified(w);
}
rule moverse_almacen {
  declarations
    practica.objetos.Area a;
    practica.objetos.Trabajador w;
    practica.objetos.Tarea t;
  preconditions
  //ES IGUAL QUE moverse_hacer_tarea_adyacente SIN LA CONDICION DE QUE EL TRABAJADOR TIENE LA HERRAMIENTA NECESARIA PARA HACER UNA TAREA
  	// Si todavía hay tareas inacabadas
  	t.getUnidades() > 0;
  	// Si ese trabajador no ha pasado ya por ese area para ir al almacen --> Evitamos hacer comprobaciones repetidas
   	!a.getVisitadaAlmacen(w.getNombre());
  actions
   	// Establecemos como area anterior del trabajador a la actual
  	w.setAreaAnterior(w.getArea());
  	// Desplazamos al trabajador al area
  	w.setArea(a.getNombre());
  	// Marcamos como visitada el area para llegar al almacen
  	a.setVisitadaAlmacen(true,w.getNombre());
  	w.imprime(t.getTipo());
  	modified(w);
  	modified(a);
}

